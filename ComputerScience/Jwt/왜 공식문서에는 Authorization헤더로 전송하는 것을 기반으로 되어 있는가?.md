
## **1. OAuth 2.0의 Client Credentials / Implicit / Authorization Code Flow 기반**
  

RFC 6750 등 표준 문서는 원래부터 **API 서버와 클라이언트가 완전히 분리된 구조**, 그리고 **브라우저/SPA보다 서버 대 서버 호출에 적합한 구조**를 상정합니다.

  

이런 구조에서는:

- 클라이언트가 토큰을 얻은 후,
    
- Access Token을 HTTP 요청 시마다
    
- **Authorization 헤더에 Bearer 형식으로 실어 보낸다**는 전제
    

```
Authorization: Bearer eyJhbGciOi...
```

이러한 방법을 왜 공식문서에서 표기하고 사용하는지에 대한 의문이 들었습니다.

---

## **쿠키 기반 방식은** OAuth의 표준 흐름 밖에 있음

  

공식 문서에서 쿠키 기반 전송(예: HttpOnly 쿠키로 자동 전송)은 보안상 매우 유효하지만,

**OAuth 프로토콜 수준에서 명시된 방식은 아닙니다.**

- 이유: OAuth는 **브라우저 상태 관리(Cookie, Session)**와 분리된 **토큰 기반 stateless 구조**를 지향
    
- 쿠키 전송은 CSRF, SameSite 등 브라우저 특유의 보안 이슈가 끼어들므로, **프로토콜 차원에서 다루지 않음**
    

  

즉, 쿠키 방식은 **OAuth를 기반으로 한 인증 시스템을 구현할 때 개발자가 선택하는 옵션이지**,

**OAuth 자체의 표준 흐름에는 포함되지 않음**

왜?

stateless API 중심으로 설계되었으며 서버에서 서버로 통하는 인증방법을 상정한 요소이기 때문

---

## **그럼 쿠키 방식은 왜 등장한 걸까?**

  

SPA, 모바일, 웹 프론트엔드 쪽에서 다음과 같은 실무 문제가 발생하면서 쿠키 기반 방식이 주류 대안이 됨:

|**문제 상황**|**쿠키 방식이 해결하는 지점**|
|---|---|
|Access Token을 저장하기 위해 localStorage를 쓰면 XSS 위험|→ HttpOnly 쿠키는 JS 접근 차단 가능|
|Authorization 헤더는 클라이언트가 직접 넣어야 해서 구현 복잡|→ 쿠키는 자동 전송되므로 클라이언트 로직 단순화|
|Refresh Token 관리가 복잡하고 노출 위험 있음|→ 쿠키 + SameSite 속성 활용 가능|

→ **실무에서는 OAuth 표준에 “맞추기보다”, 이를 변형해서 더 안전하고 간결한 방식으로 구현하는 방향으로 발전 중**

---

## **결론 정리**

| **항목**                       | **설명**                                      |
| ---------------------------- | ------------------------------------------- |
| 왜 공식은 Authorization 헤더 방식인가? | OAuth 2.0의 기본 전제가 그렇기 때문 (stateless API 중심) |
| Refresh Token 유무와 관련 있나?     | 없음. Refresh Token이 있어도 Access Token은 헤더 전송  |
| 그럼 왜 우리는 쿠키도 쓰는가?            | 브라우저 기반 앱의 보안과 편의성, 특히 XSS 대비 목적            |
| 쿠키 방식은 비표준인가?                | OAuth 공식에는 없음. 하지만 실무에서는 널리 사용              |
