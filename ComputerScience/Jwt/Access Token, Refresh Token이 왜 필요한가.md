
## **Access Token / Refresh Token이 등장한 배경**

  
### **JWT의** 고정 유효시간(exp) 한계 = 권한 회수 문제

- JWT는 발급 시점에 exp(만료 시간)를 **고정**해서 넣음
- 한번 발급된 토큰은 만료까지 **서버에서 강제로 회수 불가**
    → 예: 로그인 해제(logout), 탈퇴, 권한 회수 시에도 **토큰은 계속 유효**
- 그래서 너무 긴 만료시간을 주면 **보안 리스크**,
    반대로 너무 짧게 하면 **사용자 경험(UX)** 악화 (계속 로그인 풀림)
  

➡️ 이 문제를 **보완**하기 위해 등장한 구조가 바로  
**Access Token (짧게) + Refresh Token (길게)** 이중 구조

---

###  **짧은 Access Token만 쓰면 되는 것 아닌가?

- 예: Access Token을 5분짜리로 설정한 경우
- 5분마다 다시 로그인해야 함 ➜ UX 파괴


➡️ 이 문제를 해결하기 위해 **Refresh Token**이 생김

  
사용자는 **긴 시간 동안 로그인 상태 유지**하되,
서버는 **짧은 Access Token을 주고 자주 검증**함으로써 보안 유지

---

### **Refresh Token이 필요한 이유**

- Access Token은 일반적으로 **서버에 저장하지 않음** (Stateless)
- 이 때문에 회수하기 어려운 구조임
- 짧은 생명주기를 부여하기에는 UX적으로 손해
- UX적으로 Refresh Token으로 Access Token을 자동으로 다시 발급하게 하여  보완
- 보안적으로 Refresh Token을 사용하며 **Refresh Token은 서버에 저장**
    → 탈취되었을 때 **서버에서 차단하거나 폐기 가능**
- 보통 DB나 Redis 등에 저장하여 **재발급 여부 검증**에 사용

➡️ 이로써 “로그인 유지”와 “보안성”을 동시에 추구하는 구조 완성

---

## **구조 비교 요약**

| **항목** | **Access Token**               | **Refresh Token**  |
| ------ | ------------------------------ | ------------------ |
| 목적     | 인증 (Authorization)             | 재발급 (Reissue)      |
| 유효 기간  | 짧음 (5~30분)                     | 김 (7일 ~ 수개월)       |
| 저장 위치  | 클라이언트 (localStorage, cookie 등) | 서버 (DB, Redis 등)   |
| 보안 중요도 | 낮음 (노출되면 재발급으로 복구 가능)          | 높음 (노출 시 계정 탈취 위험) |
| 재발급 여부 | 불가                             | 가능 (Access 재발급용)   |

---

## **정리**

  

**Access Token / Refresh Token** 구조는:

- JWT의 **회수 불가능한 성질**
- 사용자 경험(UX)과 보안을 **동시에 만족시키기 위한 설계**
- 실무에서의 **로그아웃 처리, 토큰 탈취 대응, 재인증 전략** 등과 직접 연결됨