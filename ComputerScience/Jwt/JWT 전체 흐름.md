# **JWT의 사용 흐름 정리**
  

JWT(JSON Web Token)는 서버가 인증된 사용자에게 토큰을 발급하고, 이후 요청마다 이 토큰을 활용해 인증 상태를 유지하는 방식.

세션 기반 인증과 달리 서버가 상태를 보관하지 않기 때문에, **Stateless 구조**에서 인증 방식으로 널리 사용됨.

아래는 JWT를 사용하는 일반적인 흐름을 단계별로 정리한 내용.

---

## **1. 사용자 로그인 요청**

  

클라이언트가 사용자 정보를 입력하고 서버로 인증 요청 전송

보통 POST /login 등의 API를 통해 수행됨

  

### **전달 정보**

- 아이디, 비밀번호 또는 OAuth2 인증 정보
    
- 서버는 DB 또는 외부 인증 서버를 통해 자격 확인 수행
    

---

## **2. 서버에서 JWT 생성 및 응답**

  

인증에 성공하면 서버는 사용자 정보를 기반으로 JWT를 생성

생성된 토큰을 클라이언트에 응답으로 전달

  

### **포함 정보**

- Header: 서명 알고리즘 정보 (예: HS256, RS256)
    
- Payload: 사용자 식별자(sub), 만료 시간(exp), 권한(role) 등
    
- Signature: 서버 비밀 키 또는 개인 키를 이용해 생성된 서명
    

  

### **응답 형태 예시 (JSON)**

```
{
  "accessToken": "<JWT_STRING>",
  "expiresIn": 3600
}
```

### **expiresIn** **을 따로 보내는 이유**

- JWT 내부의 exp는 클라이언트가 직접 디코딩해야 확인 가능
    
- 클라이언트 앱(브라우저, 모바일 등)에서는 **UI 갱신, 자동 로그아웃, 재요청 스케줄링** 등을 위해 **명시적인 만료 시간 정보를 필요로 함**
    
- expiresIn 필드를 통해 토큰의 남은 유효 시간을 초 단위로 제공하면
    
    → 클라이언트는 디코딩 없이도 만료 시점을 계산하여 관리 가능
    

---

## **3. 클라이언트가 토큰 저장**

  

클라이언트는 서버로부터 전달받은 JWT를 저장

이후 요청 시 이 토큰을 함께 전송하여 인증 상태 유지

  

### **저장 위치**

- 웹 브라우저 환경:
    
    - localStorage 또는 sessionStorage
        
    - 또는 HttpOnly Cookie로 저장하여 XSS 방지 가능
        
    
- 모바일/SPA 환경:
    
    - 로컬 파일 또는 안전한 토큰 저장소 사용 권장
        
    

---

## **4. 인증이 필요한 요청 시 토큰 전송**

  

클라이언트는 API 요청 시 JWT를 HTTP Header에 포함하여 서버로 전송

서버는 토큰의 유효성을 검사하고 요청 처리

  

### **요청 방식**

```
GET /api/user/me HTTP/1.1
Authorization: Bearer <JWT_STRING>
```

---

## **5. 서버에서 토큰 검증 및 사용자 식별**

  

서버는 전달받은 JWT를 다음 기준으로 검증

  

### **검증 항목**

- 서명 유효성 (Signature 검증)
    
- 만료 여부 (exp 클레임 검사)
    
- 사용자 권한 및 액세스 범위 (role, scope 등 클레임 검사)
    

  

검증에 성공하면 Payload에서 사용자 정보를 추출하고 요청을 처리

---

## **6. 토큰 만료 시 처리 흐름**

  

JWT는 exp 클레임 기반으로 유효 시간이 지나면 만료 처리됨

클라이언트는 만료된 토큰으로 요청을 보낼 수는 있으나, **서버는 이 토큰을 거부함**

  

### **만료 처리 방식**

- JWT는 클라이언트 측에서 **자동으로 파기되지 않음**
    
- 브라우저나 앱은 만료 여부를 판단하지 않음
    
- **서버가 매 요청마다 exp 값을 검사하여 유효성 판단**
    

  

### **검증 실패 예시**

```
HTTP/1.1 401 Unauthorized
{
  "error": "TokenExpiredError",
  "message": "Access token has expired"
}
```

### **실무 대응 방법**

- Access Token은 일반적으로 **짧은 유효기간(예: 15분 이내)** 설정
    
- Refresh Token은 장기 인증 수단으로 사용하여 만료된 Access Token 재발급
    
- 클라이언트는 expiresIn 또는 JWT 내부 exp 값을 기준으로
    
    → 토큰 갱신 시점을 사전 계산하거나, 만료 응답을 수신한 후 재발급 요청 수행
    
---

## **흐름 요약**

|**단계**|**설명**|
|---|---|
|1|클라이언트가 로그인 요청 전송|
|2|서버가 사용자 인증 후 JWT 생성|
|3|클라이언트가 JWT 저장|
|4|API 요청 시 JWT를 Authorization 헤더에 포함|
|5|서버가 JWT 서명, 만료 여부 등을 검증|
|6|유효하면 요청 처리, 실패 시 오류 응답 또는 재인증 요청|

---

## **실무 고려사항**

- 토큰 탈취 방지를 위한 HTTPS 통신 필수
    
- 저장 위치에 따라 XSS 또는 CSRF 방지 전략 달라짐
    
- 로그아웃 처리 또는 토큰 블랙리스트 처리 방식 설계 필요
    
- Refresh Token 사용 시 추가적인 보안 정책 적용 필요
    

---

## **마무리**

  

JWT의 사용 흐름은 단순하지만, 각 단계마다 **보안 정책, 저장 방식, 만료 전략**에 따라 전체 시스템의 안정성이 크게 좌우됨.

토큰 생성부터 검증, 재발급까지의 흐름을 명확하게 설계하면 Stateless 구조에서도 안전하고 효율적인 인증 시스템 구축 가능.
