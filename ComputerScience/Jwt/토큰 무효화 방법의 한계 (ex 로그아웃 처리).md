
# **JWT 토큰 무효화 방법의 한계 (예: 로그아웃 처리)**

  

JWT는 서버 상태를 저장하지 않는 **Stateless 인증 방식**을 지향함.

따라서 한 번 발급된 토큰은 **서버가 직접 통제하거나 강제로 만료시키기 어려움**

이러한 구조는 효율성과 확장성에 장점이 있으나, **로그아웃 처리 또는 토큰 회수와 같은 무효화 작업에서 구조적 한계를 가짐**

---

## **1. 기본 전제: JWT는 자체 유효기간만으로 동작**

- JWT는 발급 시점에 만료 시각(exp)이 포함됨
    
- 서버는 만료 시각 이전까지 토큰을 **신뢰**함
    
- 서버는 기본적으로 **어떤 토큰이 발급되었는지 저장하지 않음**
    

이 말은 곧, **사용자가 로그아웃하거나 탈퇴해도 그 토큰은 여전히 유효**하다는 것을 의미함

---

## **2. JWT의 로그아웃 처리의 어려움**

  

### **문제 상황**

- 사용자가 로그아웃 요청을 보냄
    
- 서버는 클라이언트의 토큰을 폐기하고 싶지만, **JWT는 클라이언트가 가진 문자열일 뿐**
    
- 별도 저장소 없이 서버는 해당 토큰을 **차단할 수 없음**
    

---

## **3. 토큰 무효화(Logout) 처리 방식과 한계**

|**방식**|**개요**|**한계**|
|---|---|---|
|클라이언트 토큰 삭제|localStorage 또는 cookie에서 삭제|클라이언트가 의도적으로 토큰을 보존하면 여전히 사용 가능|
|Access Token 짧게 + Refresh Token 관리|Access Token은 짧은 수명, Refresh는 서버에서 검증|Refresh Token이 탈취되면 방지 어려움|
|서버 측 블랙리스트|로그아웃된 토큰을 저장해 서버에서 필터링|저장소 부담, 검색 비용 증가, 토큰이 Stateless하지 않게 됨|
|토큰 버전(version) 관리|사용자마다 토큰 발급 시점 버전 저장 후, 요청마다 비교|토큰 구조에 버전 포함 필요, 실시간 갱신 필요|
|로그아웃 전용 토큰 식별자(jti) 차단|jti 값을 기준으로 무효 토큰을 식별|대량 사용자 시 성능 문제, 저장소 필요|

---

## **4. 블랙리스트 방식의 구조적 타협**

  

### **개념**

- 로그아웃 요청 시 서버는 해당 JWT의 jti 또는 전체 토큰 문자열을 별도 저장소(Redis 등)에 저장
    
- 이후 요청마다 이 토큰이 **차단 목록(Blacklist)**에 포함되어 있는지 검사
    

  

### **한계**

- 저장소 부하 증가
    
- 요청 처리 지연 가능성
    
- TTL 설정 없을 경우 메모리 낭비
    
- 완전한 Stateless 구조 포기
    

---

## **5. 실무 권장 전략**

| **구성**                | **역할**                                   |
| --------------------- | ---------------------------------------- |
| Access Token (짧은 수명)  | 짧은 인증 유지 (5분 ~ 30분)                      |
| Refresh Token (서버 저장) | 장기 인증 유지 및 재발급용                          |
| 클라이언트 로그아웃 시          | Refresh Token 삭제, Access Token은 만료되도록 방치 |
| 민감 정보 변경 시            | Access + Refresh 모두 재발급하여 기존 토큰 폐기       |
| 관리 필요 시               | Redis 등을 통한 Blacklist 운영 (TTL 설정 필수)     |

---

## **마무리**

  

JWT는 Stateless 구조이기 때문에 토큰 자체를 **서버가 회수하거나 무효화하는 데 제약**이 있음

특히 로그아웃 처리나 사용자 권한 변경, 탈퇴 등 **즉시 적용이 필요한 시나리오에서 단점**으로 작용함

  

이러한 한계를 해결하기 위해 다음과 같은 전략이 필요함:

1. **짧은 Access Token + Refresh Token 구조 설계**
    
2. **Refresh Token 서버 저장 (DB 또는 Redis)**
    
3. **필요한 경우에 한해 블랙리스트 전략 채택**
    
4. **중요 이벤트 발생 시 토큰 전체 재발급**
    

JWT의 장점(확장성, 무상태성)을 유지하면서도 단점을 보완하는 방식으로 설계해야 안정적인 인증 구조 확보 가능