
## JWT가 필요한 이유

  

### **Stateless 인증이 필요해서 (서버에 인증 상태 저장 X)**

  

기존의 세션 기반 인증은:

- 로그인하면 **서버 메모리에 세션을 저장**하고
    
- 클라이언트는 세션 ID를 쿠키로 보냄
    
- 서버가 이 ID를 매번 조회해서 인증 상태 유지
    

  

하지만 이 방식은:

- 서버가 **인증 상태를 기억(상태ful)**해야 함 → **서버 확장 시 문제**
    
- **로드 밸런서나 여러 서버가 있을 때 세션 공유 필요** (ex: Redis 등 외부 저장소 필요)
    

  

→ JWT는 **“Stateless 인증 방식”**

: 서버는 **토큰만 검증**하고 아무것도 저장하지 않음 → **확장성과 성능**이 뛰어남

---

###  2.분산 시스템, 마이크로서비스 환경에 적합

- 여러 서비스 간에 사용자 정보를 공유하려면, 중앙 인증 서버에서 매번 사용자 정보를 조회해야 함
    
- JWT는 **토큰 자체에 인증 정보를 포함**하기 때문에
    
    → 인증 서버에서 한 번 발급하면, 다른 서비스에서도 **토큰 검증만으로 인증 가능**
    

  따라서 **API Gateway, Microservice, OAuth2 연동 등**에서 필수적인 구조

---

### 요청마다 인증 정보를 포함할 수 있음

- REST API는 **무상태(Stateless) 통신**을 전제로 함
    
- 매 요청마다 서버는 사용자 인증 여부를 다시 판단해야 함

→ JWT는 Authorization: Bearer <토큰> 헤더로 인증 정보 전송 가능

→ RESTful 설계와 잘 맞음

---

### **서명 기반으로 위·변조 방지가 가능**

- JWT는 **Header + Payload + Signature**로 구성되며,
    
- 서명이 있으므로, **중간에 토큰이 변경되었는지 쉽게 검증 가능**
    

  

✅ ⇒ **신뢰성과 무결성 보장**

---

### **토큰에 커스터마이징된 정보 포함 가능**

- userId, role, email 등 커스텀 클레임을 담을 수 있음
    
- 서버에서 별도 DB 조회 없이 **토큰 하나로 사용자 권한 체크 가능**
    

  

→ ex: 관리자 여부, 만료 시간, 닉네임 등

---

### **🔁 6.** Access Token + Refresh Token 구조로 유연한 인증 처리 가능

- Access Token: 짧은 유효기간 → 탈취 위험 줄이기
    
- Refresh Token: 새 토큰 재발급 전용 → 로그인 유지 편리성 확보

✅ 보안성과 UX를 모두 고려한 **토큰 전략 설계 가능**