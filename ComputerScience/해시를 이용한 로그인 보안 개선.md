# **해시를 이용한 로그인 보안 개선**

  

사용자 인증 기능을 개발할 때 가장 중요한 보안 고려사항 중 하나는 **비밀번호 처리 방식**이다. 단순히 비밀번호를 저장하거나 비교하는 것은 보안상 매우 취약하며, 이로 인해 해시(Hash)와 솔팅(Salting) 기법이 등장했다. 이 글에서는 **왜 해시가 필요한지**, **해시란 무엇인지**, 그리고 **솔트와 솔팅 처리 과정**까지 단계적으로 정리한다.

---

## **해시가 필요한 이유**

  

### **1. 평문 저장의 위험성**

비밀번호를 데이터베이스에 그대로 저장할 경우, 해당 데이터베이스가 유출되면 사용자의 모든 계정 정보가 고스란히 노출된다. 특히 많은 사용자가 여러 서비스에서 같은 비밀번호를 재사용하기 때문에 **1건의 유출이 전체 계정 도용으로 확산될 수 있다.**

### **2. 되돌릴 수 없는 보안 처리가 필요**

  
해시는 입력값을 **복원 불가능한 일방향 함수로 변환**하여 저장한다. 따라서 유출이 되어도 원래 비밀번호를 알아내기 어렵다.

예시:

```
password123 → SHA-256 → ef92b778bafe771e8925...
```

비밀번호를 복호화하지 않고도 로그인 처리가 가능하므로, 데이터 유출 시에도 안전성을 유지할 수 있다.

---

## **해시란 무엇인가**

### **1. 해시 함수의 정의**

  

해시(Hash)는 임의의 입력값을 고정된 길이의 무작위 문자열로 변환하는 함수다. 해시 함수는 다음과 같은 특성을 가진다.

|**속성**|**설명**|
|---|---|
|일방향성|해시값으로부터 원래 값을 복원할 수 없음|
|고정 길이 출력|입력 길이에 관계없이 항상 일정한 길이|
|충돌 회피성|서로 다른 입력이 같은 해시값을 가질 가능성이 매우 낮음|

### **2. 자주 사용되는 해시 알고리즘**

- SHA-256
    
- SHA-512
    
- MD5 (보안상 현재는 권장되지 않음)
    

---

## **해시만 사용할 경우의 보안 문제**

  

단순 해싱만 사용할 경우, 다음과 같은 공격에 취약하다.

|**위험 요소**|**설명**|
|---|---|
|동일한 입력 = 동일한 해시|모든 사용자가 password123을 사용하면 동일한 해시값 저장됨|
|레인보우 테이블 공격|미리 계산된 비밀번호-해시값 쌍을 활용해 빠르게 역산 가능|

따라서 해시만으로는 안전한 비밀번호 보호가 어렵다. 이를 보완하기 위해 등장한 개념이 바로 솔팅이다.

---

## **솔트(Salt)의 개념**

  

### **1. 솔트란?**

  

**솔트(Salt)**는 비밀번호에 추가로 붙이는 **임의의 난수 값**이다. 동일한 비밀번호라도 서로 다른 솔트를 붙이면 **서로 다른 해시값을 생성**할 수 있다.

  

예시:

```
password123 → SHA-256 → 8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918
password123 + salt("Xyz#1!") → SHA-256 → ??????????
```

### **2. 솔트의 목적**

- 동일한 비밀번호라도 해시값이 다르게 만들어져 **패턴 분석 불가**
    
- 레인보우 테이블을 사용할 수 없음 (비밀번호마다 해시값이 달라짐)
    

---

## **솔팅 기반 비밀번호 처리 흐름**

  

### **1. 회원가입 시 처리 절차**

1. 사용자가 비밀번호를 입력함
    
2. 서버가 난수 솔트를 생성함 (SecureRandom 사용)
    
3. 비밀번호 + 솔트를 붙여 해싱함
    
4. 해시 결과와 솔트를 **모두 저장**
    

```
{
  "userId": "user123",
  "passwordHash": "b3e4d2f...",
  "salt": "Xyz#1!"
}
```

### **2. 로그인 시 처리 절차**

1. 사용자가 비밀번호를 입력함
    
2. DB에서 해당 사용자의 솔트를 가져옴
    
3. 비밀번호 + 솔트를 붙여 같은 해시 알고리즘으로 해싱
    
4. 저장된 해시값과 비교하여 로그인 성공 여부 결정
    

---

## **솔팅 적용 예시 (Java + SHA-256 기준)**

```
public class PasswordUtil {
    public static String sha256WithSalt(String password, String salt) {
        String input = salt + password;
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(input.getBytes());

            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

---

## **실무에서는 어떻게 처리하는가**

  

실무에서는 SHA-256 + Salt 방식을 직접 구현하지 않고, 아래와 같은 라이브러리를 사용한다.

|**알고리즘**|**특징**|
|---|---|
|BCrypt|자동 솔트 포함, 느린 연산 → 공격자 방어|
|Scrypt|메모리 사용량 조절 가능|
|Argon2|최신 알고리즘, 다양한 보안 설정 지원|

Spring Security의 BCryptPasswordEncoder는 내부적으로 솔트를 자동 적용하며, 실무에서 널리 사용된다.

---

## **정리**

| **항목**    | **내용**                    |
| --------- | ------------------------- |
| 해시 사용 이유  | 평문 저장 방지, 일방향성 보장         |
| 단순 해싱의 문제 | 동일 해시값, 레인보우 테이블 공격       |
| 솔트의 역할    | 비밀번호마다 고유한 해시값 생성         |
| 실무 권장 방식  | BCrypt 등 솔트 포함 해시 알고리즘 사용 |
