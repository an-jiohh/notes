## **Unique Index**


Unique Index(유니크 인덱스)는 데이터베이스의 인덱스 중 하나로, 특정 컬럼의 값이 중복되지 않도록 보장하는 인덱스이다. 
일반 인덱스가 단순히 조회 성능 향상을 위한 것이라면, 유니크 인덱스는 데이터 무결성(Integrity)을 강제하는 역할도 수행하기도 하는데 이를 이용한 것이 Unique Index를 이용한 동시성 제어이다.

---

### **등장 배경**

- 데이터의 중복을 막아야 하는 경우가 많음
    
    - 예시: 이메일, 아이디, 주민등록번호, 학번 등
        
    
- 단순한 데이터 검증 로직만으로는 다중 트랜잭션 상황에서 중복을 완벽히 차단하기 어려움
    
- 이를 시스템 차원(DB 엔진 레벨)에서 강제하기 위해 등장
    

### **동작 원리**

- 유니크 인덱스는 **B+Tree**, **Hash** 등의 인덱스 구조 위에 동작
    
- 데이터를 추가 또는 수정할 때, 해당 인덱스에 이미 동일한 값이 존재하는지 검사
    
- 이미 존재하면 오류를 발생시켜 트랜잭션을 롤백
    
- 존재하지 않으면 정상적으로 데이터 반영
    

---

### **일반 인덱스와 차이점**

|**구분**|**일반 인덱스**|**유니크 인덱스**|
|---|---|---|
|목적|조회 성능 향상|조회 성능 향상 + 중복 데이터 방지|
|중복 허용 여부|허용|**허용 안 됨**|
|데이터 무결성|보장하지 않음|보장함|
|성능 차이|거의 동일|거의 동일 (단, 삽입/갱신 시 중복 검사로 약간의 오버헤드)|

---

### **생성 방법 (SQL 예시)**

```
-- 단일 컬럼 유니크 인덱스
CREATE UNIQUE INDEX idx_user_email ON user(email);

-- 테이블 생성 시 유니크 인덱스 지정
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    username VARCHAR(100)
);

-- 다중 컬럼 유니크 인덱스
CREATE UNIQUE INDEX idx_user_name_email ON user(username, email);
```

---

### **주의 사항**

- NULL 값 처리
    
    - RDBMS마다 다름
        
    - 일반적으로 NULL은 서로 다른 값으로 간주되어 여러 개 허용
        
    
- **다중 컬럼 유니크 인덱스**
    
    - 지정된 모든 컬럼의 조합이 유일해야 함
        
    - 하나의 컬럼만 따로 중복되어도 조합이 다르면 허용
        
    

---

### **실무 활용 예시**

|**상황**|**유니크 인덱스 활용 이유**|
|---|---|
|회원 가입 시 이메일 중복 방지|동시성 상황에서도 DB 차원에서 중복 완벽 차단|
|주문번호, 송장번호 등 고유 식별값 관리|비즈니스 로직 실수나 시스템 오류로 인한 중복 방지|
|특정 속성 조합이 중복되면 안 되는 경우|(예: 같은 프로젝트 내 동일한 파일명)|

---

### **유니크 인덱스와 동시성**

- 흔히 **낙관적 락(Optimistic Lock)**이나 **비관적 락(Pessimistic Lock)**을 사용하지 않더라도 **유니크 인덱스만으로도 동시성 문제를 일부 해결 가능**
    
- 특히 다중 트랜잭션이 동시에 insert하는 상황에서 중복 여부를 검사하는 로직을 신뢰할 수 없을 때 유용
    

**생성(INSERT) 시의 동시성**을 제어 할 수 있음
- **동일한 값의 중복 삽입 방지**
- **동일한 자원의 중복 예약 방지**
- **경쟁 상황에서 선착순 확보 구현**

---
### **실무 예시 1: 선착순 이벤트 참여**  

**상황:** 한 사용자가 이벤트에 중복 참여하면 안 되는 경우.

```sql
CREATE TABLE event_entry (
    user_id BIGINT NOT NULL,
    event_id BIGINT NOT NULL,
    PRIMARY KEY (event_id, user_id)
);
```

**동작 원리:**

- event_id + user_id 조합에 유니크 제약을 걸어둠
- 여러 스레드 혹은 프로세스가 동시에 INSERT 시도하더라도
- DB가 먼저 INSERT한 트랜잭션 외에는 모두 **제약조건 오류로 실패**

  

**따라서:**

- 별도의 락 로직 없이 **DB가 동시성 경쟁을 해결**
- 실패한 쪽은 오류 캐치 후 재시도 로직이나 실패 응답 처리

---

### **실무 예시 2: 유니크 쿠폰 발급**

  

**상황:** 한 명당 특정 쿠폰은 한 번만 발급 가능해야 함.

```sql
CREATE TABLE coupon (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    code VARCHAR(50) UNIQUE,
    user_id BIGINT UNIQUE
);
```

**동작:**

- user_id에 유니크 인덱스 설정
    
- 쿠폰 발급 시 해당 컬럼으로 INSERT
    
- 동시에 두 번 발급 요청이 와도 DB가 먼저 도착한 요청만 성공
    

---

### **실무 예시 3: 비즈니스 키 중복 방지**

  

**상황:** 이메일이나 닉네임 같은 비즈니스 키가 중복되면 안 되는 경우.

```sql
ALTER TABLE user ADD CONSTRAINT unique_email UNIQUE (email);
```

**동작:**

- 회원 가입 또는 수정 시 중복 검증 없이 바로 INSERT/UPDATE 시도
    
- 동시 요청이 있더라도 DB가 중복을 차단
    

---

### **한계와 주의사항**

- **낙관적 락이나 비관적 락의 완전 대체는 아님**
    
- **상태 변경을 동반하는 복잡한 로직에는 부족**
    
- 트랜잭션 범위 내에서 비즈니스 로직을 처리해야 하는 경우 여전히 락이 필요
    
- 유니크 인덱스 충돌을 어플리케이션 단에서 잘 핸들링해야 함 (try-catch 등)