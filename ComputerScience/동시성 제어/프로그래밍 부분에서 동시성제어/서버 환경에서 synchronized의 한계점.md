## **서버 환경에서 synchronized의 한계점**

  

synchronized는 자바 언어 차원에서 동기화를 단순하고 안전하게 구현할 수 있는 방법이지만,  
서버 환경 또는 대규모 시스템에서는 몇 가지 명확한 한계와 제약이 존재한다.

  

### **1. 단일 JVM 내에서만 동작**

  

synchronized는 **JVM 프로세스 내부의 스레드 동기화**에만 영향을 미친다.

따라서 다음과 같은 상황에서는 아무런 효과가 없다.

- 서버가 **여러 JVM 인스턴스**로 구동될 때
    
- 서버가 **클러스터 환경**으로 운영될 때
    
- 서버가 **컨테이너 기반으로 수평 확장**될 때
    
  

즉, synchronized는 기본적으로 **로컬 프로세스 단위의 락**일 뿐, 분산 시스템 수준의 동기화는 제공하지 않는다.

  

### **2. 락 경합에 따른 성능 저하**

  

멀티스레드 환경에서 락 경합이 심할 경우 다음과 같은 문제가 발생할 수 있다.

- 스레드가 락을 얻기 위해 대기 → **응답 지연 증가**
    
- 락 경합으로 인한 CPU 소모 증가
    
- 특히 Heavyweight Lock(무거운 락)으로 전환될 경우 시스템 리소스 사용량 급증
    

  

실제 서버에서 트래픽이 몰릴 때, 락이 남용되면 전체 처리량이 급격히 떨어질 수 있다.

  

### **3. 락 범위 관리 어려움**

  

synchronized는 코드 블록 또는 메서드 단위로 락을 걸기 때문에 다음과 같은 문제가 있다.

- **세밀한 락 제어가 어렵다**
    
- 락의 범위가 넓어질수록 불필요한 대기 시간이 발생한다
    
- 반대로 락의 범위를 잘못 설정하면 동기화 누락이 발생할 수 있다
    

  

서버 비즈니스 로직이 복잡해질수록 락 관리 실수가 시스템 오류로 직결될 가능성이 높아진다.

  

### **4. 교착 상태(Deadlock) 위험**

  

synchronized를 여러 객체 또는 여러 락에 걸쳐서 사용할 경우 락 획득 순서에 따라 교착 상태가 발생할 수 있다. 서버 애플리케이션에서 교착 상태는 다음과 같은 심각한 문제를 유발한다.

- 해당 스레드 무한 대기
    
- 전체 시스템 응답 정지
    
- 예측 불가능한 서비스 장애
    

  

### **5. 분산 락 필요성**

  

서버가 다음과 같은 구조를 가질 경우, synchronized는 실질적인 락 효과를 제공하지 못한다.

- **다중 인스턴스 구조**: WAS 인스턴스를 여러 대 띄우는 경우
    
- **컨테이너 오케스트레이션 환경**: Kubernetes, Docker Swarm 기반 운영
    
- **마이크로서비스 아키텍처**
    

  

이런 상황에서는 별도의 분산 락 시스템을 고려해야 한다.

  

### **6. 분산 락 도입 사례**

  

실제 서버 환경에서 자주 사용하는 분산 락 기술 예시는 다음과 같다.

|**기술**|**특징**|
|---|---|
|Redis 기반 분산 락 (SETNX, Redisson)|비교적 빠르고 설정이 쉬움|
|ZooKeeper 기반 분산 락|안정성과 신뢰성 우수, 상대적으로 복잡|
|DB를 이용한 분산 락|별도 시스템 없이 구현 가능하나 성능 저하 가능|
