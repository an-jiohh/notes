
# **Java synchronized**

멀티스레드 프로그래밍에서 여러 스레드가 동시에 동일한 객체나 변수에 접근하면 데이터 불일치나 예기치 않은 결과가 발생할 수 있다. 이를 방지하기 위해 자바에서는 synchronized 키워드를 제공한다. synchronized는 코드 실행 중 특정 영역에 대해 동시 접근을 제어하여 데이터 일관성을 보장하는 역할을 한다.

---

## **핵심 개념**

  

synchronized는 내부적으로 객체나 클래스 단위로 락을 걸어 한 번에 하나의 스레드만 해당 코드 블록이나 메서드를 실행할 수 있도록 한다. 이를 통해 원자성(Atomicity)과 가시성(Visibility)을 확보한다.

  

## **동작 원리**

synchronized는 JVM의 모니터(Monitor) 락을 기반으로 동작한다. 자바의 모든 객체는 내부적으로 모니터를 가지고 있으며, synchronized가 적용될 경우 이 모니터 락을 이용해 접근을 제어한다.  

락은 크게 두 가지 기준으로 구분된다.

| **구분** | **락 기준**      | **대상 메모리 영역** |
| ------ | ------------- | ------------- |
| 인스턴스 락 | this 객체       | Heap 영역       |
| 클래스 락  | 클래스명.class 객체 | Method 영역     |

### **인스턴스 메서드 동기화**

```
public synchronized void increment() {
    count++;
}
```

해당 객체의 모니터 락을 기준으로 동기화가 이루어진다. **같은 인스턴스를 공유하는 스레드**끼리만 동기화가 적용된다.
  

### **정적 메서드 동기화**

```
public static synchronized void increment() {
    staticCount++;
}
```

클래스 객체(클래스명.class)에 락이 걸리며, 인스턴스가 몇 개든 상관없이 클래스 차원에서 동기화된다.

  

### **블록 단위 동기화**

```
public void increment() {
    synchronized (this) {
        count++;
    }
}
```

필요한 코드 블록에만 선택적으로 락을 적용할 수 있다. 특정 객체를 기준으로 락을 걸 수도 있다.

```
private final Object lock = new Object();

public void increment() {
    synchronized (lock) {
        count++;
    }
}
```


---

## **JVM 메모리 구조와 모니터 락**

  

JVM에서 객체는 다음과 같은 메모리 구조를 가진다.

```
┌───────────────────────────┐
│ Mark Word (락 정보 등)    │
├───────────────────────────┤
│ Class Pointer             │
├───────────────────────────┤
│ 인스턴스 변수들           │
└───────────────────────────┘
```

**Mark Word**에는 락 상태, 해시코드, GC 정보 등이 저장된다. 락 경합 상황에 따라 다음과 같은 최적화가 적용된다.

#### **락 최적화 단계 (HotSpot JVM 기준)**

참고사항으로 락에 대해서 다음과 같은 최적화를 진행한다.

| **단계**                   | **설명**                   |
| ------------------------ | ------------------------ |
| 편향 락 (Biased Lock)       | 특정 스레드에 락을 편향시켜 빠른 처리    |
| 경량 락 (Lightweight Lock)  | 락 경쟁 시 Spin Lock으로 처리 시도 |
| 무거운 락 (Heavyweight Lock) | 심각한 경쟁 상황에서 OS 수준 락 사용   |

## **주의 사항**

#### **락 범위 최소화**

불필요하게 전체 메서드에 락을 걸면 성능 저하를 유발할 수 있다. 꼭 필요한 코드 블록에만 선택적으로 락을 걸어야 한다.

  
#### **객체 기준 관리**


여러 인스턴스가 존재할 경우 락은 각 객체별로 독립적이다. 동기화를 확실히 보장하려면 static synchronized 또는 클래스명.class를 기준으로 락을 관리해야 한다.
#### **락 경합 최소화**

스레드 경쟁이 많은 구간에서는 synchronized 대신 ReentrantLock 등 세밀한 락 제어가 가능한 도구를 고려할 수 있다.

---

### 서버환경에서의 한계점

[[서버 환경에서 synchronized의 한계점]]