동적계획법(DP, Dynamic Programming)은 **복잡한 문제를 작은 하위 문제로 나누고**, **이전 결과를 저장하여 중복 계산을 피하는** 알고리즘 설계 기법
주로 **최적화 문제**에 사용되며, **탐색의 효율성**을 크게 높일 수 있음

---

## **동적계획법의 핵심 아이디어**

  

### **1.** **중복되는 하위 문제(Subproblem)**

- 큰 문제를 작은 문제로 나누었을 때, **같은 하위 문제가 반복**해서 나타남
    
- 예: 피보나치 수열 → fib(5)를 구할 때 fib(3)을 여러 번 호출
    

  

### **2.**  **최적 부분 구조(Optimal Substructure)**

- 문제의 최적해가 **하위 문제들의 최적해로 구성**됨
    
- 예: LCS(최장 공통 부분 수열) 문제는 전체 수열의 최장 길이가 부분 수열들의 최장 길이로부터 결정됨
    

---

## **DP 구현 방법**

  

### **방법 1:**  **Top-down (메모이제이션, 재귀 + 캐싱)**

```
def fib(n):
    if n <= 1:
        return n
    if memo[n] != -1:
        return memo[n]
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]

memo = [-1] * 100
print(fib(10))
```

### **방법 2:**  **Bottom-up (반복문 + 테이블)**

```
def fib(n):
    dp = [0] * (n+1)
    dp[1] = 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

print(fib(10))
```

---

## **사용 예시**

|**문제**|**설명**|
|---|---|
|피보나치 수열|가장 기본적인 DP 문제|
|계단 오르기|한 번에 1칸 또는 2칸 오를 수 있을 때 방법 수|
|동전 교환 문제|최소 동전 개수로 금액 만들기|
|배낭 문제 (Knapsack)|무게 제한 내에서 최대 가치 얻기|
|LCS|두 문자열의 최장 공통 부분 수열 길이|

---

## **동적계획법과 관련된 개념 구분**

|**이름**|**특징**|
|---|---|
|재귀|문제를 나누고 함수로 반복 호출|
|메모이제이션|재귀 + 캐싱 (Top-down)|
|DP (Bottom-up)|반복문으로 테이블 채우기|
|그리디|지역 최적 선택이 전체 최적을 보장할 때 사용|

---

## **동적계획법 적용 4단계**

1. **문제를 부분 문제로 나눌 수 있는가?**
    
2. **중복되는 부분 문제인가?**
    
3. **작은 문제의 정답으로 큰 문제의 정답을 구할 수 있는가?**
    
4. **테이블(배열)로 결과를 저장할 수 있는가?**
    