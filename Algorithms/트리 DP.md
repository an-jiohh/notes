# Tree DP

트리 DP(Tree DP)는 말 그대로 **트리 구조에서 수행하는 동적 계획법(DP)** 
- > 리프 노드부터 시작해 → 부모 노드로 올라가며 → DP 값을 계산한다.

---

## **트리 DP란?**

- **트리 구조(그래프 중 싸이클이 없는 구조)**에서
    
- **DP(중복 계산을 줄이기 위한 메모이제이션 기법)**를 사용하여
    
- **서브트리에서의 최적해를 이용해 상위 노드의 최적해를 구하는 방법**입니다.
    

쉽게 말해,

> “자식 노드들의 정보를 이용해서 부모 노드의 값을 계산하는 방식의 DP”입니다.

---

## **📌 일반 DP vs 트리 DP 비교**

|**구분**|**일반 DP 예시**|**트리 DP 예시**|
|---|---|---|
|구조|선형 구조, 배열|트리(계층형 그래프)|
|접근 방식|인덱스를 순서대로 처리|DFS를 통해 자식 → 부모 순으로 처리|
|예시 문제|피보나치 수열, 배낭 문제|얼리어답터 문제, 트리의 최대 독립 집합 등|

---

## **✅ 트리 DP의 핵심 3가지**

1. **상태 정의**
    
    → 각 노드에서의 상태를 어떻게 표현할지 정해야 함
    
    예: dp[node][0] = 이 노드가 얼리어답터일 때 최소 얼리어답터 수
    
2. **점화식 구성**
    
    → 자식 노드들의 정보를 활용해서 현재 노드의 값을 계산
    
    예: dp[node][0] = 1 + sum(min(dp[child][0], dp[child][1]))
    
3. **DFS로 처리 순서 정리**
    
    → 리프(말단)부터 루트까지 계산해야 하므로 DFS로 자식 먼저 탐색한 뒤 계산
    
    (post-order DFS)
    

---

## **🎯 대표적인 트리 DP 문제 유형**

|**유형**|**설명**|
|---|---|
|얼리어답터 문제 (BOJ 2533)|일반인 주변은 모두 얼리어답터여야 함|
|트리의 독립 집합 문제|서로 인접하지 않은 정점들의 최대 집합|
|트리의 지름 구하기|가장 긴 경로를 구하는 문제|
|트리에서 최대 경로의 합 문제|경로의 합이 최대가 되는 경로 찾기|

---

## **📌 예시 그림**

```
        1
      / | \
     2  3  4
       / \
      5   6
```

각 노드가 일반인/얼리어답터일 수 있고,

5~6번은 리프 → 먼저 계산

3번은 5,6번 결과를 가지고 계산

1번은 2,3,4번 결과를 보고 계산함

  

→ 이 흐름이 바로 **트리 DP = DFS + DP** 구조입니다.

---

## **요약**

|**키워드**|**설명**|
|---|---|
|구조|트리 (싸이클 없음)|
|순서|DFS (후위 순회)|
|활용|자식 정보를 기반으로 부모 계산|
|핵심 기법|메모이제이션 + 재귀|
