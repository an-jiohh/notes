# **비트마스크**

**n개의 상태**를 각각 0(꺼짐) 또는 1(켜짐)으로 표현하고 싶을 때, n비트 정수를 사용해 한 번에 저장/관리하는 방식

예: 00010110 → 2번, 3번, 5번 비트가 켜져 있음

**장점**
- 메모리 절약 (boolean 배열보다 훨씬 작음)
- 연산 속도 빠름 (비트 연산은 O(1))
- 부분집합 탐색 등에 매우 유리함

## 주요 연산

| **연산 종류** | **연산자** | **의미**          |
| --------- | ------- | --------------- |
| AND       | &       | 공통된 비트 확인       |
| OR        | `       | `               |
| XOR       | ^       | 서로 다르면 1        |
| NOT       | ~       | 비트 반전           |
| Shift     | <<, >>  | 비트를 왼쪽/오른쪽으로 이동 |

## **자주 나오는 문제 유형**

- 부분집합 관련 DP (e.g., 외판원 순회)
- 집합 관리 (e.g., 원소 추가/삭제/토글 문제)
- 그래프에서 상태 저장 = - DFS 상태 백트래킹에 유용함 (특정 노드만 토글로 되돌림 가능)
- 백트래킹 시 상태 최적화

주로 
- 특정 노드만 토글로 되돌림 가능
- 원소 추가/삭제/토글 연산이 **O(1) 연산**
- 메모리 크기 최적화를 위해 사용하는 듯

---
## Python에서의 비트마스크

### 비트 생성

파이썬에서 이진수를 표현할 때에는 숫자 앞에 **0b**를 붙혀서 표현

```python
my_bit = 0b10110101
print(my_bit) # 181
```

**bin** 메소드를 이용하여 이진수로 표현할 수 있음

```python
my_num = 181
print(bin(my_num)) # 0b10110101
```

SHIFT연산을 이용해서 임의의 위치에 비트를 존재하게 할 수 있음

```python
target = 1 << (n - 1)
```

### SHIFT 연산(위치 옮기기)

```python
a << 1 # a의 모든 비트를 왼쪽으로 1만큼 이동합니다.  
a >> 1 # a의 모든 비트를 오른쪽으로 1만큼 이동합니다.
```

### AND 연산(원소 확인)

**&** 를 사용하여 해당위치에 원소가 있는지 확인하기 용이함

```python
if my_num & chk: 
    print(f"{n}번째 위치에 값이 있습니다.")
```

#### OR 연산(원소 추가)

**|** 를 사용하여 or연산을 통해 임의의 위치에 원소를 추가할 수 있음

```python
my_num = 0b10110101
plus = 1 << (n - 1)
my_num = my_num | plus
```

#### NOT 연산(원소 삭제)

**~** 를 사용하여 not연산이 가능함
**~** + **&** 를 사용하여 원소 삭제도 가능함

```python
check = 0b000000100
check = ~check #0b111111011
target = target & check
```

#### XOR 연산(원소 토글)

XOR 연산은 다를때 1을 반환함
**^** 을 사용하여 연산

```python
0 ^ 0 #0
0 ^ 1 #1
1 ^ 0 #1
1 ^ 1 #0
```

토글을 만들 수 있음, 해당 위치만 토글형식으로 바뀌게됨

```python
chk = 0b11 << (n - 1)
target = target ^ chk
```


---
## **Java에서의 비트마스크**

파이썬과 거의 비슷한 모습으로 사용

### **비트 생성**

Java도 동일하게 사용, 이진수를 표현할 때는 0b 접두사를 붙힘

```
int myBit = 0b10110101;
System.out.println(myBit); // 181
```

2진수로 출력하려면 Integer.toBinaryString() 사용:

```
int myNum = 181;
System.out.println(Integer.toBinaryString(myNum)); // 10110101
```

---

### **SHIFT 연산 (위치 옮기기)**

```
a << 1; // a의 모든 비트를 왼쪽으로 1만큼 이동
a >> 1; // a의 모든 비트를 오른쪽으로 1만큼 이동
```

```
int target = 1 << (n - 1);
```

---

### **AND 연산 (원소 확인)**


```
if ((myNum & chk) != 0) {
    System.out.println(n + "번째 위치에 값이 있습니다.");
}
```

---

### **OR 연산 (원소 추가)**


```
int myNum = 0b10110101;
int plus = 1 << (n - 1);
myNum = myNum | plus;
```

---

### **NOT 연산 (원소 삭제)**


```
int check = 0b00000100; // 예: 3번째 비트를 지우고 싶을 때
check = ~check;         // 11111011
target = target & check; // 해당 비트만 0으로 만들고 나머지는 유지
```

---

### **XOR 연산 (원소 토글)**

```
int chk = 0b11 << (n - 1);
target = target ^ chk;
```
