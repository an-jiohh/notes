# LCS

**LCS**란 두 개의 수열에서 **순서는 유지하되 연속하지 않아도 되는** 공통 부분 수열 중 **가장 긴 수열**을 의미

예시
- 문자열 A: ABCBDAB
- 문자열 B: BDCABA
- → 가능한 LCS: BCBA, BDAB, BCAB 등 (길이 4)

---

### Top-Down 접근

마지막 문자를 기준으로 두 문자열을 비교하여 다음과 같은 경우의 수를 진행
1. 마지막 문자가 같을 경우  
	두 문자열의 길이를 1씩 줄이고 다시 반복, 결과에 1을 더해줌
2. 마지막 문자가 다를 경우  
	- 두 문자열에서 첫 번째에서 마지막 글자를 뺀것과 두 번째 문자열을 비교(m - 1, n)
	- 첫 번째 문자열은 그대로와 두 번째 문자열에서 마지막 글자를 뺀 것 비교(m, n - 1)  
	-> 더 큰값을 가지는 것을 저장

```
1. 마지막 글자가 같은 경우 입니다.
    LCS("ACE", "CDE") = LCS("AC", "CD") + 1
2. 마지막 글자가 다를 경우 입니다.
    LCS("AC", "CD") = max(LCS("A", "CD"), LCS("AC", "C"))
3. 두 가지 경우중 더 큰 값을 리턴합니다.
    LCS("A", "CD") = 0
    LCS("AC", "C") = LCS("A", "") + 1 = 1
    0과 1중 더 큰 값인 1을 리턴
4. 최종적으로 1 + 1 = 2.
    LCS("ACE", "CDE") = 2
```


---

###  Bottom-Up 접근

```python
def lcs_length(A, B):
    n, m = len(A), len(B)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if A[i - 1] == B[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[n][m]
```

수도코드
1. 길이에 대한 이중 dp 배열 생성
2. 첫번째 반복문(1, 길이+1)
3. 두번째 반복문(1, 길이+1)
4. 문자열 비교(i-1,j-1) 
	1. 문자열이 같다면  
			현재dp{i}{j}에 dp{i-1}{j-1} + 1저장
	2. 문자열이 다르다면
			현재dp{i}{j}에 dp{i-1}{j}, dp{i}{j-1} 중 큰값 저장