# Java에서의 TimeZone 처리

## **한 눈에 비교**

|**타입**|**사람 친화**|**지역 정보**|**서버 저장**|**실무 추천**|
|---|---|---|---|---|
|LocalDateTime|◎|❌|❌|UI 한정|
|ZonedDateTime|◎|◎|△|스케줄/항공|
|OffsetDateTime|○|오프셋만|◎|**API/DB**|
|Instant|❌|❌|◎|로그/내부|

---

## **1. LocalDateTime**

  
**“달력 + 시계만 있음, 위치 개념 없음”**

```
LocalDateTime.now();
// 2025-12-29T16:10:00
```

### **특징**

- 날짜 + 시간만 표현
    
- **타임존 정보 없음**
    
- “이 시간이 어디 기준인지” 알 수 없음
    

  

### **문제점**

```
2025-12-29 16:00
```

이게

- 한국 시간?
    
- UTC?
    
- 뉴욕 시간?
    

  

→ **해석 불가**

  

### **언제 쓰나**

- **UI 표시용**
    
- “매일 9시에 알람” 같은 **절대 비교 안 하는 시간**
    
- 로컬 시스템 내부 계산
    

---

## **2. ZonedDateTime**

  

**“완전한 시간 정보 (지역 + 타임존 규칙)”**

```
ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
// 2025-12-29T16:10+09:00[Asia/Seoul]
```

### **특징**

- 지역(ZoneId) + 시간
    
- DST(서머타임)까지 반영
    
- 가장 정확한 현실 시간 모델
    

  

### **단점**

- 너무 무거움
    
- 직렬화/비교/DB 저장이 귀찮음
    
- 프론트 ↔ 백엔드 ↔ DB 전파 시 복잡
    

  

### **언제 쓰나**

- **캘린더, 스케줄, 항공편, 국제 서비스**
    
- “이 시간은 반드시 이 지역 기준이어야 한다”는 요구가 있을 때
    

---

## **3. OffsetDateTime**

**“UTC 기준 + 오프셋만 있음”**

```
OffsetDateTime.now();
// 2025-12-29T07:10:00Z
// or 2025-12-29T16:10+09:00
```

```
OffsetDateTime = LocalDateTime + ZoneOffset
```
### **특징**

- UTC 기준 시간 + +09:00 같은 오프셋
    
- **타임존 이름은 없음**
    
- 비교, 저장, 정렬이 매우 쉬움
    

  

### **장점**

- 서버/DB/API에 딱 맞음
    
- JSON 직렬화 깔끔
    
- 타임존 분쟁 없음
    

  

### **단점**

- “서울인지 도쿄인지”는 모름
    
    (하지만 대부분 서버에선 필요 없음)
    

  

### **언제 쓰나**

- **DB 저장**
    
- **REST API 응답**
    
- 로그, 이벤트 시간
    

####  **오프셋의 핵심 역할**

**절대 시간(Instant)으로 변환 가능**

```
OffsetDateTime odt = OffsetDateTime.parse("2025-12-29T16:00+09:00");
Instant instant = odt.toInstant();
// 2025-12-29T07:00Z
```
➡ **비교, 정렬, 계산 가능**
❌ LocalDateTime은 이게 안 됨
(UTC 기준이 없어서)

#### **전 세계 어디서든 같은 순간으로 인식**

```
2025-12-29T16:00+09:00 (한국)
2025-12-29T07:00Z      (UTC)
2025-12-29T02:00-05:00 (뉴욕)
```
→ **모두 같은 순간**

Offset 덕분에
- 서버 A
- 서버 B
    
- DB
    
- 클라이언트
    
모두 **같은 시점**을 다르게 표현만 할 뿐임

**Instant**와의 차이점(**“그럼 그냥 Instant만 쓰면 되잖아?”**)

맞지만, 현실적으로 
```
Instant.now();
// 1735450200.123
```
사람이 읽기 힘든 문제, API 응답으로는 불친절, API 형태가 UTC기반인 곳이 많음


➡ **OffsetDateTime = Instant + 인간 친화성**

#### **직렬화 & 표준화**
JSON / ISO-8601
```
"createdAt": "2025-12-29T16:00:00+09:00"
```
- 국제 표준으로 사용
- 프론트/백엔드/DB 공통 이해
- 변환 로직 최소화

---

## **4.** **Instant**

  

**“기계가 쓰는 절대 시간”**

```
Instant.now();
// 1735450200.123 (epoch seconds)
```

### **특징**

- UTC epoch 기준 (1970-01-01)
    
- 타임존 개념 아예 없음
    
- 전 세계 어디서든 동일
    

  

### **장점**

- 비교, 계산 최강
    
- 로그 / 성능 측정 / 이벤트 타임스탬프 최적
    

  

### **단점**

- 사람이 읽기 불편
    
- 그대로 사용자에게 보여주기엔 부적합
    

  

### **언제 쓰나**

- **로그**
    
- **TTL, 만료 시간**
    
- **성능 측정**
    


---

## **실무 추천 패턴 (중요)**

  

### **DB**

```
created_at → TIMESTAMP WITH TIME ZONE
→ OffsetDateTime / Instant
```

### **API**

```
"createdAt": "2025-12-29T16:10:00+09:00"
```

→ OffsetDateTime

  

### **UI**

```
OffsetDateTime → LocalDateTime (사용자 타임존 변환)
```

---

## **한 줄 요약**

- **저장/비교** → Instant or OffsetDateTime
    
- **API 응답** → OffsetDateTime
    
- **사용자 표시** → LocalDateTime
    
- **지역 의미가 핵심** → ZonedDateTime
    