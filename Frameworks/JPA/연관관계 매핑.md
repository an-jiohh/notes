# 연관관계 매핑

주요 요점

객체와 테이블의 연관관계의 차이  
객체 참조와 테이블의 외래키를 매핑  
방향, 다중성(1:1, N:1, 1:N, M:M), 연관관계의 주인  

---
기존의 sql방식의 테이블로 생성시 jpa가 추구하는 객체지향성격과 비슷하지않음  
```
@Column(name = "TeamId")
private long teamId
```
위와 같이 id값을 저장해야하며 이를 사용할 시에도
```
member.getTeamId().getTeamName()
```
위와 같이 사용하게됨  

객체지향성격을 바라본다면 참조형식을 선호할 것이라 생각  
JPA를 사용하는 이유와도 연관된다고 생각함  

정리하면 다음과 같음

- 테이블
	- 외래키 조인으로 연관된 테이블을 찾음
- 객체
	- 참조(주소값)으로 연관된 객체를 찾음

---
이를 JPA, 즉 객체참조로 어떻게 할 수 있는가?  

연관관계를 설정함으로 사용
```
@ManyToOne
private Team team;
```
위와 같이 사용할 경우, JPA가 테이블을 참조해 연관관계를 자동으로 매핑해줌

---
그러면 기존에 테이블에서 외래키는 어떻게됨?  
외래키없으면 어떻게 조인함?  

이거도 JPA가 해주긴하나 이상하게 해준다..

```
Hibernate: 
    create table memo (
        id bigint generated by default as identity,
        content varchar(500) not null,
        create_at timestamp(6),
        primary key (id)
    )
Hibernate: 
    create table users (
        id bigint generated by default as identity,
        name varchar(50) not null,
        password varchar(50) not null,
        role enum ('ADMIN','USER'),
        user_id varchar(50) not null,
        primary key (id)
    )
Hibernate: 
    create table users_memos (
        user_id bigint not null,
        memos_id bigint not null
    )
```
테이블 선언 로그를 참고해보면 알 수 있다.  
내가 선언하지 않은 테이블이 생성된 것을 볼 수 있다.  

JPA는 중간 조인 테이블을 이용하여 조인을 시켜버린다.  
이때 사용할 수 있는 것이  
**@JoinColumn**이다

---
## @JoinColumn

```
@ManyToOne
@JoinColumn(name="teamId")
private Team team;
```

연관관계의 주인이 되는 엔티티의 테이블에 어떤 컬럼을 외래키로 사용할지를 지정하는 애노테이션  
간단히 말해 FK를 설정하는 어노테이션이라고 나는 생각하기로 했다.  
(사실 FK 제약 조건까지 걸지 않음) = 외래키 컬럼을 만든다고 이해해도 돼. 하지만 ‘제약조건까지 만드는 건 아니다

@JoinColumn(name = "teamId")
현재의 entity 테이블에 teamId라는 컬럼으로 외래키 설정할께  
를 하는 것으로 이해하면 편할 것 같다.  

다만 해당 선언에 중요한 내용이 있다. 바로 연관관계의 주인이라는 개념이다.

---
## 연관관계 매핑

다시 객체와 테이블로 돌아와서 양방향 연관관계를 살펴본다면 다음과 같다.

테이블의 연관관계
회원 <--> 팀 = 연관관계 1개

객체의 연관관계
회원 -> 팀 = 연관관계 1개
팀 -> 회원 = 연관관계 1개
총 연관관계 2개

객체는 참조를 이용하기 때문에 연관관계가 2개가 존재하는데  
이때 어떤 연관관계가 주인인지 설정해야하는 요소가 발생한다.  

이때 연관관계의 주인은 직접 관리하는 엔티티의 필드가 되게된다.  
바로 위에서 이야기하였던 @JoinColumn이다.  

정리하면 연관관계의 주인은 다음과 같은 특징을 가진다.  

- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
- 주인이 아닌 쪽은 읽기만 가능
- 주인은 mappedBy 사용 X
- 주인이 아니라면 mappedBy 속성으로 주인을 지정해줘야함

그렇다면 주인은 누구로 설정해야하는가?  
간단하게 테이블 설계를 진행했을때 외래키가 존재하는 테이블을 연관관계의 주인으로 설정하면 된다.  

---
## mappedBy
주인이 아닌 쪽에서는 연관관계 매핑(OneToMany or ManyToOne) 속성으로 mappedBy를 걸어줘야한다.
```
// memo.java
@ManyToOne
@JoinColumn(name = "user_id")  // FK는 Memo 테이블에 존재
private User user;
```

```
// user.java
@OneToMany(mappedBy = "user")
private List<Memo> memos;
```
이때 연관관계 주인에 있는 객체의 필드명을 적어줘야한다.  

왜?  
user가 Memo의 user필드가 fk를 들고있어 -> 라고 말해주는 뜻으로 작동한다.  
-> jpa는 객체 각 관계로 관리하기 때문에 필드로 입력한다고 한다. 

### mappedBy를 생략하면?
JPA가 **단방향으로 오해**하고 → 조인 테이블 생성
```
@Entity
public class Memo {
    @ManyToOne
    @JoinColumn(name = "user_id") // FK 관리 → 이쪽이 주인
    private User user;
}

@Entity
public class User {
    @OneToMany
    private List<Memo> memos;
}
```
- Memo는 @JoinColumn으로 명확히 **FK를 들고 있으니 주인**
- 그런데 User는 mappedBy가 없음 = “**나도 주인이야!**“라고 착각

JPA는 다음과 같이 착각  
“어? Memo.user도 관계고, User.memos도 관계인데… 둘 다 주인 아님을 명시 안했네? 그럼 둘 다 주인이구나!”

이후 User → Memo는 **단방향 OneToMany**로 처리됨  
- **OneToMany 단방향**은 DB상에서 FK를 못 박기 힘들기 때문에, JPA는 조인 테이블을 따로 만듦

---
## 양방향 매핑시 많이 하는 실수

### 연관관계의 주인에 값을 입력하지 않음
```
Team team = new Team();
team. setName ("TeamA");
em. persist (team);

Member member = new Member();
member.setName("member1");


//역방향(주인이 아닌 방향)만 연관관계 설정
team.getMembers().add(member);

em. persist (member);
```

결과

| id  | username | teamId |
| --- | -------- | ------ |
| 1   | member1  | null   |

member가 연관관계의 주인일때 이렇게 사용하면 설정이 되지 않는다.  
즉, 주인에서 입력을 해줘야한다.  

**순수한 객체지향 관계를 고려한다면 양쪽 다 값을 입력해줘야한다.**

```
Team team = new Team();
team. setName ("TeamA");
em. persist (team);

Member member = new Member();
member.setName("member1");

team.getMembers().add(member);
member.setTeam(Team)

em. persist (member);
```
이렇게 거는 것이 일반적이다.

왜?
```
Team team = new Team();
team. setName ("TeamA");
em. persist (team);

Member member = new Member();
member.setName("member1");

//team.getMembers().add(member); 한쪽만 값을 넣어준 상황
member.setTeam(Team) //연관관계의 주인을 수정(정상)

em. persist (member);

//em.flush(); DB에 넣지 않고 그대로 1차 캐시에만 존재 = 트랜잭션발생시 flush
Team findTeam = em.find(Team.class, team.Id())
List<Member> newTeamMembers = findTeam.getMembers();
```
연관관게의 주인인 멤버에 team 세팅 → 주인에게만 걸고 flush없이 다시사용하면
1차캐시인 메모리에서 해당 정보를 들고옴 = flush되지않고 디비에서 연관관계가 반영되지 않음

이를 그대로 사용하기 때문에
연관관계 매핑(DB에 반영된것을 들고온 것이 아니므로, 멤버가 없다고 뜸)

결론
혹시 나도 모르게 생각한 비즈니스 로직에 맞추어 되지않을 수도 있으니 양뱡향 연관관계 때는 둘다 설정하는 것을 추천  
추천 -> 하나만 세팅시 둘다 세팅할 수 있도록 엔티티내의 연관관계 편의 메소드를 선언하는 것을 추천

```
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();

    public void addMember(Member member) {
        members.add(member);
        member.setTeam(this);  // 양방향 연관관계 세팅
    }
}

@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    private Team team;

    public void setTeam(Team team) {
        this.team = team;
    }
}
```

---
## 진짜 마지막으로 양방향 매핑을 위한 정리

사실 단방향 매핑으로도 이미 연관관계 매핑은 완료  
양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것일 뿐  
JPQL에서 역방향으로 탐색할 일이 많음  
단방향 매핑을 잘하고 필요시 양방향을 추가해도 괜찮음 = 테이블 구조가 변하지 않기 때문  

비즈니스 로직간에 양방향이 필요없는 경우도 많음,  
필요하지 않을 경우 관계를 떨어뜨려 결합도를 낮추는 것도 개발자의 역량  

예)


Order -> Member O  
주문은 항상 “누가 주문했는지” 알아야 함. 즉, Order는 반드시 Member 정보를 포함해야 의미가 있음  

Member -> Order ??  
유저 정보를 바탕으로 주문 내용을 찾을 경우가 존재하긴함  
하지만 보통 member를 조회하면서 order을 조회하는 경우는 흔치않음, 즉 member로 부터 order로 전이되는 경우  
memberId를 바탕으로 order을 찾는 것이 좀 더 비즈니스 적으로 흔한 경우이다  